#ifndef ARION_CODE_TRACE_ANALYSIS_HPP
#define ARION_CODE_TRACE_ANALYSIS_HPP

#include <arion/common/code_tracer.hpp>
#include <arion/common/global_defs.hpp>
#include <fstream>
#include <map>
#include <string>

namespace arion
{

/// This structure holds data relative to a module being traced (e.g : a library) in virtual memory space.
struct TRACE_MODULE
{
    /// The module id.
    uint16_t mod_id;
    /// A string describing the module.
    std::string name;
    /// The MD5 checksum of the module.
    std::string hash;
    /// Start address of the module.
    ADDR start;
    /// End address of the module.
    ADDR end;

    /**
     * Builder for TRACE_MODULE instances.
     */
    TRACE_MODULE() {};
    /**
     * Builder for TRACE_MODULE instances.
     * @param[in] mod_id The module id.
     * @param[in] name A string describing the module.
     * @param[in] hash The MD5 checksum of the module.
     * @param[in] start Start address of the module.
     * @param[in] end End address of the module.
     */
    TRACE_MODULE(uint16_t mod_id, std::string name, std::string hash, ADDR start, ADDR end)
        : mod_id(mod_id), name(name), hash(hash), start(start), end(end) {};
    /**
     * Builder for TRACE_MODULE instances used to clone a TRACE_MODULE instance.
     * @param[in] mod The TRACE_MODULE to be cloned.
     */
    TRACE_MODULE(TRACE_MODULE *mod)
        : mod_id(mod->mod_id), name(mod->name), hash(mod->hash), start(mod->start), end(mod->end) {};
};

/// This class is used to read and parse an execution trace generated by an arion::CodeTracer instance.
class CodeTraceReader
{
  private:
    /// Path to the trace file.
    std::string trace_path;
    /// Stream instance for the trace file.
    std::ifstream trace_f;
    /// Size in bytes of the trace file.
    size_t trace_f_sz;
    /// Version of the trace file.
    float version;
    /// The TRACE_MODE used to generate the trace file.
    TRACE_MODE mode;
    /// Amount of hits (e.g : instructions, basic blocks...) in the trace file.
    size_t total_hits;
    /// List of registers making up the context for TRACE_MODE::CTXT traces.
    std::vector<REG> ctxt_regs;
    /// Offset in bytes to the sections table of the trace file.
    off_t secs_table_off;
    /// Offset in bytes to the modules section of the trace file.
    off_t mod_sec_off;
    /// Offset in bytes to the registers section of the trace file.
    off_t regs_sec_off;
    /// Offset in bytes to the data section of the trace file.
    off_t data_sec_off;
    /// Current hit index.
    off_t hit_i;
    /// Map of modules in the trace file, given their id.
    std::map<uint16_t, std::unique_ptr<TRACE_MODULE>> modules;
    /**
     * Reads and parses the header section of the trace file.
     */
    void read_header();
    /**
     * Reads and parses the sections table of the trace file.
     */
    void read_sections_table();
    /**
     * Reads and parses the modules section of the trace file.
     */
    void read_modules_section();
    /**
     * Reads and parses the registers section of the trace file.
     */
    void read_regs_section();
    /**
     * Prepares the parser to read the data section containing all the hits.
     */
    void prepare_file();

  public:
    /**
     * Builder for CodeTraceReader instances.
     * @param[in] trace_path Path to the trace file.
     */
    CodeTraceReader(std::string trace_path);
    /**
     * Retrieves the current hit being parsed.
     * @return The current hit being parsed.
     */
    std::unique_ptr<CODE_HIT> curr_hit();
    /**
     * Retrieves the next hit to be parsed.
     * @return The next hit to be parsed.
     */
    std::unique_ptr<CODE_HIT> next_hit();
    /**
     * Retrieves the next hit in the given module to be parsed.
     * @param[in] mod_id ID of the module to find next hit from.
     * @return The next hit in the given module to be parsed.
     */
    std::unique_ptr<CODE_HIT> next_mod_hit(uint16_t mod_id);
    /**
     * Tells the reader to advance until it reaches a given PC address in a hit.
     * @param[in] addr The address to reach.
     * @return The hit containing the given PC address.
     */
    std::unique_ptr<CODE_HIT> reach_addr(ADDR addr);
    /**
     * Tells the reader to advance until it reaches a given PC offset from a module start in a hit.
     * @param[in] mod_id ID of the module to compute offset from.
     * @param[in] off The offset to reach.
     * @return The hit containing the given PC offset.
     */
    std::unique_ptr<CODE_HIT> reach_off(uint16_t mod_id, uint32_t off);
    /**
     * Retrieves the current hit index.
     * @return The current hit index.
     */
    off_t get_hit_index();
    /**
     * Sets the current hit index to a new value.
     * @param[in] hit_i The new hit index.
     */
    void set_hit_index(off_t hit_i);
    /**
     * Resets the reading cursor in the input trace file.
     */
    void reset_hit_cursor();
    /**
     * Retrieves the TRACE_MODE used to generate the trace file.
     * @return The TRACE_MODE used to generate the trace file.
     */
    TRACE_MODE get_mode();
    /**
     * Retrieves a TRACE_MODULE given its ID.
     * @param[in] mod_id ID of the module to be retrieved.
     * @return The TRACE_MODULE instance.
     */
    std::unique_ptr<TRACE_MODULE> get_module(uint16_t mod_id);
    /**
     * Retrieves a TRACE_MODULE given its name.
     * @param[in] name Name of the module to be retrieved.
     * @return The TRACE_MODULE instance.
     */
    std::unique_ptr<TRACE_MODULE> find_module_from_name(std::string name);
    /**
     * Retrieves a TRACE_MODULE given its hash.
     * @param[in] hash Hash of the module to be retrieved.
     * @return The TRACE_MODULE instance.
     */
    std::unique_ptr<TRACE_MODULE> find_module_from_hash(std::string hash);
    /**
     * Checks whether the trace file contains the given context register. Only makes sense for files generated with
     * TRACE_MODE::CTXT.
     * @param[in] reg The register to be checked.
     * @return True if the trace file contains the given context register.
     */
    bool has_reg(REG reg);
};

/// This structure holds data relative to a trace hit (e.g : instruction, basic block...).
struct ARION_EXPORT ANALYSIS_HIT
{
    /// Index of the hit in the trace file.
    off_t hit_i;
    /// Name of the module where the hit occurred.
    std::string mod_name;
    /// Offset to the module start in bytes.
    uint32_t off;
    /// Size of the hit in bytes.
    uint16_t sz;
    /// Map of context register values given their associated register. Only makes sense for files generated with
    /// TRACE_MODE::CTXT.
    std::unique_ptr<std::map<REG, RVAL>> regs;

    /**
     * Builder for ANALYSIS_HIT instances.
     */
    ANALYSIS_HIT();
    /**
     * Builder for ANALYSIS_HIT instances.
     * @param[in] hit_i Index of the hit in the trace file.
     * @param[in] mod_name Name of the module where the hit occurred.
     * @param[in] off Offset to the module start in bytes.
     * @param[in] sz Size of the hit in bytes.
     * @param[in] regs Map of context register values given their associated register. Only makes sense for files
     * generated with TRACE_MODE::CTXT.
     */
    ANALYSIS_HIT(off_t hit_i, std::string mod_name, uint32_t off, uint16_t sz, std::map<REG, RVAL> *regs)
        : hit_i(hit_i), mod_name(mod_name), off(off), sz(sz), regs(std::make_unique<std::map<REG, RVAL>>(*regs)) {};
};

/// Callback called when a hit is being processed by a CodeTraceAnalyzer instance.
using ANALYZER_HIT_CALLBACK = std::function<bool(std::unique_ptr<ANALYSIS_HIT> hit)>;

/// This class is used to analyze data held in a trace file with various methods.
class ARION_EXPORT CodeTraceAnalyzer
{
  private:
    /// The CodeTraceReader used to parse the trace file.
    CodeTraceReader reader;

  public:
    /**
     * Builder for CodeTraceAnalyzer instances.
     * @param[in] trace_path Path to the trace file.
     */
    ARION_EXPORT CodeTraceAnalyzer(std::string trace_path);
    /**
     * Tells the underlying reader to advance until it reaches a given PC address in a hit.
     * @param[in] addr The address to reach.
     * @return The hit containing the given PC address.
     */
    void ARION_EXPORT reach_address(ADDR addr);
    /**
     * Tells the underlying reader to advance until it reaches a given PC offset from a module start in a hit.
     * @param[in] mod_id ID of the module to compute offset from.
     * @param[in] off The offset to reach.
     * @return The hit containing the given PC offset.
     */
    void ARION_EXPORT reach_offset(std::string name, uint32_t off);
    /**
     * Calls the given callback on every hit contained in the trace file.
     * @param[in] callback The callback to be called for each hit.
     * @param[in] reset_cursor Whether the cursor of the underlying reader should be reset to the top of the trace file.
     */
    void ARION_EXPORT loop_on_every_hit(ANALYZER_HIT_CALLBACK callback, bool reset_cursor = true);
    /**
     * Calls the given callback on every hit contained in a given module from the trace file.
     * @param[in] callback The callback to be called for each module hit.
     * @param[in] name Name of the module to process.
     * @param[in] reset_cursor Whether the cursor of the underlying reader should be reset to the top of the trace file.
     */
    void ARION_EXPORT loop_on_every_mod_hit(ANALYZER_HIT_CALLBACK callback, std::string name, bool reset_cursor = true);
    /**
     * Calls the callback when a hit contains the given PC address.
     * @param[in] callback The callback to be called when the PC address is reached.
     * @param[in] addr The address to be reached.
     * @param[in] reset_cursor Whether the cursor of the underlying reader should be reset to the top of the trace file.
     */
    void ARION_EXPORT search_hit_address(ANALYZER_HIT_CALLBACK callback, ADDR addr, bool reset_cursor = true);
    /**
     * Calls the callback when a hit PC address is contained in the specified bounds.
     * @param[in] callback The callback to be called when the PC address is in the specified bounds.
     * @param[in] start_addr Start address of the code range to be reached.
     * @param[in] end_addr End address of the code area to be reached.
     * @param[in] reset_cursor Whether the cursor of the underlying reader should be reset to the top of the trace file.
     */
    void ARION_EXPORT search_hit_address_range(ANALYZER_HIT_CALLBACK callback, ADDR start_addr, ADDR end_addr,
                                               bool reset_cursor = true);
    /**
     * Calls the callback when a hit PC address is a given module offset.
     * @param[in] callback The callback to be called when the module offset is reached.
     * @param[in] name Name of the module to compute the offset from.
     * @param[in] off Offset of the module to be reached.
     * @param[in] reset_cursor Whether the cursor of the underlying reader should be reset to the top of the trace file.
     */
    void ARION_EXPORT search_hit_offset(ANALYZER_HIT_CALLBACK callback, std::string name, uint32_t off,
                                        bool reset_cursor = true);
    /**
     * Calls the callback when a hit PC address is at a given module range.
     * @param[in] callback The callback to be called when the module range is reached.
     * @param[in] name Name of the module to compute the range from.
     * @param[in] start_off Start offset of the module range to be reached.
     * @param[in] end_off End offset of the module range to be reached.
     * @param[in] reset_cursor Whether the cursor of the underlying reader should be reset to the top of the trace file.
     */
    void ARION_EXPORT search_hit_offset_range(ANALYZER_HIT_CALLBACK callback, std::string name, ADDR start_off,
                                              ADDR end_off, bool reset_cursor = true);

    /**
     * Calls the callback when a hit contains a given register value. Only makes sense for files generated with
     * TRACE_MODE::CTXT.
     * @tparam T A RVAL type large enough to store the register value.
     * @param[in] callback The callback to be called when the register value is reached.
     * @param[in] reg The context register which is being monitored.
     * @param[in] val The register value to be reached.
     */
    template <typename T> void ARION_EXPORT search_reg_val(ANALYZER_HIT_CALLBACK callback, REG reg, T val)
    {
        if (this->reader.get_mode() != TRACE_MODE::CTXT)
            throw arion_exception::WrongTraceModeException();
        if (!this->reader.has_reg(reg))
            throw arion_exception::UnknownTraceRegException(reg);

        this->reader.reset_hit_cursor();
        std::unique_ptr<CODE_HIT> hit;
        while ((hit = this->reader.next_hit()))
        {
            RVAL hit_val = hit->regs->at(reg);
            bool is_equal = false;
            if constexpr (std::is_same_v<T, RVAL8>)
                if (hit_val.r8 != val)
                    continue;
            if constexpr (std::is_same_v<T, RVAL16>)
                if (hit_val.r16 != val)
                    continue;
            if constexpr (std::is_same_v<T, RVAL32>)
                if (hit_val.r32 != val)
                    continue;
            if constexpr (std::is_same_v<T, RVAL64>)
                if (hit_val.r64 != val)
                    continue;
            if constexpr (std::is_same_v<T, RVAL128>)
                if (hit_val.r128 != val)
                    continue;
            if constexpr (std::is_same_v<T, RVAL256>)
                if (hit_val.r256 != val)
                    continue;
            if constexpr (std::is_same_v<T, RVAL512>)
                if (hit_val.r512 != val)
                    continue;
            std::unique_ptr<TRACE_MODULE> mod = this->reader.get_module(hit->mod_id);
            if (!callback(std::make_unique<ANALYSIS_HIT>(mod->name, hit->off, hit->sz, hit->regs.get())))
                return;
        }
    }
};

/// Callback called when a hit is being processed by a CodeTraceComparator instance.
using COMPARATOR_HIT_CALLBACK =
    std::function<bool(std::unique_ptr<ANALYSIS_HIT> hit1, std::unique_ptr<ANALYSIS_HIT> hit2)>;

/// This class is used to compare data held in two different trace files with various methods.
class ARION_EXPORT CodeTraceComparator
{
  private:
    /// The CodeTraceReader used to parse the first trace file.
    CodeTraceReader reader1;
    /// The CodeTraceReader used to parse the second trace file.
    CodeTraceReader reader2;

  public:
    /**
     * Builder instance for CodeTraceComparator instances.
     * @param[in] trace_path1 Path to the first trace file.
     * @param[in] trace_path1 Path to the second trace file.
     */
    ARION_EXPORT CodeTraceComparator(std::string trace_path1, std::string trace_path2);
    /**
     * Tells the underlying readers to advance until they reach a given PC address in a hit.
     * @param[in] addr The address to reach.
     */
    void ARION_EXPORT merge_at_address(ADDR addr);
    /**
     * Tells the underlying readers to advance until they reach a given PC offset from a module start in a hit.
     * @param[in] name Name of the module to compute the offset from.
     * @parma[in] off The offset to reach.
     */
    void ARION_EXPORT merge_at_offset(std::string name, uint32_t off);
    /**
     * Calls the callback when the hits from the trace files contain a different PC module offset.
     * @param[in] callback The callback to be called when a different PC module offset is reached.
     * @param[in] reset_cursors Whether the cursors of the underlying readers should be reset to the top of the trace
     * files.
     */
    void ARION_EXPORT search_uneq_hit_offset(COMPARATOR_HIT_CALLBACK callback, bool reset_cursors = true);
    /**
     * Calls the callback when the hits from the trace files contain a different PC module offset in a given module.
     * @param[in] callback The callback to be called when a different PC module offset is reached in the module.
     * @param[in] name Name of the module to be processed.
     * @param[in] reset_cursors Whether the cursors of the underlying readers should be reset to the top of the trace
     * files.
     */
    void ARION_EXPORT search_uneq_hit_offset_mod(COMPARATOR_HIT_CALLBACK callback, std::string name,
                                                 bool reset_cursors = true);
    /**
     * Calls the callback when the hits from the trace files contain a different context register value. Only makes
     * sense for files generated with TRACE_MODE::CTXT.
     * @param[in] callback The callback to be called when a different context register value is reached.
     * @param[in] reset_cursors Whether the cursors of the underlying readers should be reset to the top of the trace
     * files.
     */
    void ARION_EXPORT search_uneq_reg(COMPARATOR_HIT_CALLBACK callback, bool reset_cursors = true);
};

}; // namespace arion

#endif // ARION_CODE_TRACE_ANALYSIS_HPP
