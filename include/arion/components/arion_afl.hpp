#ifndef ARION_ARION_AFL_HPP
#define ARION_ARION_AFL_HPP

#include <arion/arion.hpp>
#include <arion/unicornafl/unicornafl.h>
#include <memory>
#include <sys/signal.h>

namespace arion
{

/**
 * A callback that gets triggered at each input generation by AFL.
 * @param[in] arion The Arion instance being fuzzed.
 * @param[in] input The buffer containing the input generated by AFL.
 * @param[in] input_sz The size of the buffer containing the input generated by AFL.
 * @param[in] persistent_round The number of remaining rounds before a fork occurs to restore a perfect state.
 * @param[in] user_data Optional user-defined data passed to the hook.
 * @return True if the input is accepted.
 */
using ARION_AFL_INPUT_CALLBACK = std::function<bool(std::shared_ptr<Arion> arion, char *input, size_t input_sz,
                                                    uint32_t persistent_round, void *user_data)>;
/**
 * A callback that gets triggered at each target crash detected by AFL.
 * @param[in] arion The Arion instance being fuzzed.
 * @param[in] res Error code returned from Unicorn engine.
 * @param[in] input The buffer containing the input generated by AFL.
 * @param[in] input_sz The size of the buffer containing the input generated by AFL.
 * @param[in] persistent_round The number of remaining rounds before a fork occurs to restore a perfect state.
 * @param[in] user_data Optional user-defined data passed to the hook.
 * @return True if the execution should indeed be considered a crash.
 */
using ARION_AFL_CRASH_CALLBACK = std::function<bool(std::shared_ptr<Arion> arion, uc_err res, char *input,
                                                    size_t input_sz, uint32_t persistent_round, void *user_data)>;

/// Memory restoring strategies for the fuzzed Arion instance.
enum ARION_MEM_STRATEGY
{
    RECORD_EDITS,     ///< All memory changes are tracked, in order to restore only edited regions.
    RESTORE_MAPPINGS, ///< Memory regions are restored, without caring about the data they contain.
    RAW_RESTORE,      ///< Everything is restored.
    MANUAL_MANAGEMENT ///< Nothing is restored.
};

/// This structure is placed in the UnicornAFL user_data parameter.
struct ARION_AFL_PARAM
{
    /// The Arion instance being fuzzed.
    std::weak_ptr<Arion> arion;
    /// The original context of the Arion instance, before fuzzing started.
    std::shared_ptr<ARION_CONTEXT> ctxt;
    /// The memory restoring strategy.
    ARION_MEM_STRATEGY mem_strategy;
    /// This callback gets triggered at each input generation by AFL, allowing the user to inject the input in the Arion
    /// instance.
    ARION_AFL_INPUT_CALLBACK input_callback;
    /// This callback gets triggered at each target crash detected by AFL.
    ARION_AFL_CRASH_CALLBACK crash_callback;
    /// Optional user-defined data passed to the hook.
    void *user_data;
    /**
     * Builder for ARION_AFL_PARAM instances.
     * @param[in] arion The Arion instance being fuzzed.
     * @param[in] ctxt The original context of the Arion instance, before fuzzing started.
     * @param[in] mem_strategy The memory restoring strategy.
     * @param[in] input_callback This callback gets triggered at each input generation by AFL, allowing the user to
     * inject the input in the Arion instance.
     * @param[in] crash_callback This callback gets triggered at each target crash detected by AFL.
     * @param[in] user_data Optional user-defined data passed to the hook.
     */
    ARION_AFL_PARAM(std::weak_ptr<Arion> arion, std::shared_ptr<ARION_CONTEXT> ctxt, ARION_MEM_STRATEGY mem_strategy,
                    ARION_AFL_INPUT_CALLBACK input_callback, ARION_AFL_CRASH_CALLBACK crash_callback, void *user_data)
        : arion(arion), ctxt(ctxt), mem_strategy(mem_strategy), input_callback(input_callback),
          crash_callback(crash_callback), user_data(user_data) {};
};

/// A map identifying a UnicornAFL error message given its error code.
inline std::map<uc_afl_ret, std::string> UC_AFL_ERR_STR = {
    {UC_AFL_RET_CHILD, "Fork worked. We are a child (no error)."},
    {UC_AFL_RET_NO_AFL, "No AFL, no need to fork (but no real error)."},
    {UC_AFL_RET_FINISHED, "We forked before but now AFL is gone (time to quit)."},
    {UC_AFL_RET_CALLED_TWICE, "Forkserver already running. This may be an error."},
    {UC_AFL_RET_ERROR, "Something went horribly wrong in the parent."}};

/// This class is used to managed a UnicornAFL fuzzing session from an Arion instance.
class ARION_EXPORT ArionAfl
{
  private:
    /// The Arion instance associated with this fuzzing session.
    std::weak_ptr<Arion> arion;
    /**
     * A callback that gets triggered at each input generation by AFL.
     * @param[in] uc The Unicorn engine associated with the Arion instance.
     * @param[in] input The buffer containing the input generated by AFL.
     * @param[in] input_sz The size of the buffer containing the input generated by AFL.
     * @param[in] persistent_round The number of remaining rounds before a fork occurs to restore a perfect state.
     * @param[in] user_data The ARION_AFL_PARAM structure for the fuzzing session.
     * @return True if the input is accepted.
     */
    static bool uc_input_callback(uc_engine *uc, char *input, size_t input_sz, uint32_t persistent_round,
                                  void *user_data);
    /**
     * A callback that gets triggered at each target crash detected by AFL.
     * @param[in] uc The Unicorn engine associated with the Arion instance.
     * @param[in] res Error code returned from Unicorn engine.
     * @param[in] input The buffer containing the input generated by AFL.
     * @param[in] input_sz The size of the buffer containing the input generated by AFL.
     * @param[in] persistent_round The number of remaining rounds before a fork occurs to restore a perfect state.
     * @param[in] user_data The ARION_AFL_PARAM structure for the fuzzing session.
     * @return True if the crash is handled.
     */
    static bool uc_crash_callback(uc_engine *uc, uc_err res, char *input, int input_len, int persistent_round,
                                  void *user_data);

  public:
    /**
     * Builder for ArionAfl instances.
     * @param[in] Arion The Arion instance associated with this fuzzing session.
     */
    ARION_EXPORT ArionAfl(std::weak_ptr<Arion> arion) : arion(arion) {};
    /**
     * Starts a fuzzing session.
     * @param[in] input_callback The callback that gets triggered at each input generation by AFL.
     * @param[in] crash_callback The callback that gets triggered at each target crash detected by AFL.
     * @param[in] exits A list of code addresses, which, when reached, stop the current execution.
     * @param[in] mem_strategy The memory restoring strategy.
     * @param[in] signals The list of signals which ArionAfl must consider crashes.
     * @param[in] always_validate If true, the crash_callback will be called after every execution.
     * @param[in] persistent_iters The number of executions before forking, and then restoring the context perfectly
     * (but an expensive operation).
     * @param[in] user_data Optional user-defined data passed to the hook.
     */
    void ARION_EXPORT fuzz(ARION_AFL_INPUT_CALLBACK input_callback, ARION_AFL_CRASH_CALLBACK crash_callback,
                           std::vector<ADDR> exits, ARION_MEM_STRATEGY mem_strategy = ARION_MEM_STRATEGY::RECORD_EDITS,
                           std::vector<int> signals = {SIGSEGV, SIGABRT}, bool always_validate = false,
                           uint32_t persistent_iters = 1000, void *user_data = nullptr);
};

}; // namespace arion

#endif // ARION_ARION_AFL_HPP
